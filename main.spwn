
// CONFIG


lines = $.readfile("./ddlc-decompiled/scripts.rpa/script-ch0.rpy").split("\r\n")

_COLOR = 2c
_OUTLINE_COLOR = 1c
_CIRCLE_COLOR = 3c
_RED_COLOR = 4c // this needs to be static in order for image cache to work

PLAYER_NAME = "bombie"
LEVEL_DURATION = 10 * 60 // seconds

GENERATE_IMAGES = true
// caching may be unstable if you modify the code (it may cause the level to be *literally* unplayable)
CACHE_IMAGES = true
READ_CACHED_IMAGES = false // disable this if you dont have a file named "./cached_output.txt" that you didnt make


// END OF CONFIG




gs = import gamescene
sprites = import "sprites.spwn"
extract obj_props


_TEXT_GROUP = ?g
_WIPE_SCENE_GROUP = ?g
_NAME_HOLDER_GROUP = ?g
_INVISIBLE_GROUP = ?g
let _TEXT_SECTION_GROUPS = [?g]

// these are static because of the image caching thing
_BACKGROUNDS_GROUP = 1g
_SCENE_GROUP = 2g
_IMAGE_OUTLINE_GROUP = 3g
let _BG_GROUPS = []

PLAYER_SPEED = 8.3705 // slow speed
TAB_SIZE = 4

sprite_pos_start = {l_pos: 0, r_pos: 0, head_pos: 0, char_pos: 0}

// using manual groups because of the caching system lmfao
let CHARACTERS = {
    narrator: { name: "", },
    s: { name: "???", pos: {x: 80, y: 50}, group: 11g, visible: false, 
        head_group: 12g, l_group: 13g, r_group: 14g, char_group: 15g, sprite_pos: sprite_pos_start, added_sprites: [], },
    m: { name: "Girl 3", pos: {x: 80, y: 50}, group: 21g, visible: false, 
        head_group: 22g, l_group: 23g, r_group: 24g, char_group: 25g, sprite_pos: sprite_pos_start, added_sprites: [], },
    n: { name: "Girl 2", pos: {x: 80, y: 50}, group: 31g, visible: false, 
        head_group: 32g, l_group: 33g, r_group: 34g, char_group: 35g, sprite_pos: sprite_pos_start, added_sprites: [], },
    y: { name: "Girl 1", pos: {x: 80, y: 50}, group: 41g, visible: false, 
        head_group: 42g, l_group: 43g, r_group: 44g, char_group: 45g, sprite_pos: sprite_pos_start, added_sprites: [], },
    ny: { name: "Nat & Yuri", },
    mc: { name:  PLAYER_NAME, },
}

MAIN_CHARACTERS_KEYS = ["s", "m", "n", "y"]
CHARACTERS_TOKENS = ["narrator", "s", "m", "n", "y", "ny", "mc"]
CHARACTERS_NAMES = [" *empty* ", "Sayori", "Yuri", "Monika", "Natsuki", "Nat & Yuri", PLAYER_NAME]
BACKGROUNDS = ["residential_day", "class_day", "club_day", "corridor"]
BACKGROUND_FILE_NAMES = ["bg/residential.png", "bg/class.png", "bg/club.png", "bg/corridor.png"]

LABELS_EXCLUSION_LIST = ["ch0_kill"]
WITH_TOKEN_WAIT_TIMES = {"wipeleft_scene": 1, "wipeleft": 0.2}

TOKENS = ["scene", CHARACTERS_TOKENS, "$", "show", "hide", "with"].flatten()

let current_character = "your mother"
let current_bg = "residential_day"
let words = 0

in_scene_transition_counter = counter(false)

// this adds the no fade object and the no bg effect object
$.add(obj{HVS: ";1,1819,2,-29,3,15,36,1,57,1001;1,22,2,-29,3,45,36,1,57,1001"})

let cached_images = {}
readed_cached_images = $.readfile("./cache_output.txt", "json") if READ_CACHED_IMAGES else {} // misspelled ikik but it makes more sense than "read"
image_output = match GENERATE_IMAGES { ==true: $.readfile("./output.txt", "json") }

image = (file_name: @string, groups: @array, x_off: @number = 0, y_off: @number = 0, z_order: @number = -5, draw_outline: @bool = true) {
    if GENERATE_IMAGES == false { return }

    if CACHE_IMAGES { let cached_images[file_name] = "" }
    frame_data = image_output[file_name]
    frame_res = frame_data.res
    frame = frame_data.image.reverse() // this is the actual image

    size = 1/(frame_res[0]/10)+0.01

    if READ_CACHED_IMAGES && readed_cached_images.get(file_name, default=null) != null {
        // we use this to compress the cache lmao, it removes like half of the size without that much of a performance hit so im ok with it
        $.add(obj{HVS: ";"+readed_cached_images[file_name].replace("\\$", "1,211,25,-2,24,{},32,{},41,1,21,4,57,2.1001.".fmt([z_order, @string(size).substr(0, 5)]))+"1,1,2,-999"})
        cached_images[file_name] += readed_cached_images[file_name]

        $.print(file_name, " added from cache")
        return
    }

    outline = (x: @number, y: @number) {
        // just realized i can use min max lmfao, oh well
        left = x - 1 if x > 0 else 0
        right = x + 1 if x < frame_res[0] else x
        up = y - 1 if y > 0 else 0
        down = y + 1 if y < frame_res[1] else y
        
        // we only need one of them to be true, then we can draw an outline, this way we save a ton of objs
        return frame[y][left] == [] || frame[y][right] == [] || frame[up][x] == [] || frame[down][x] == []
    }

    let img_objs_to_cache = ""
    for j in 0..frame_res[0] {
        for i in frame_res[1]..0 {
            if frame[j][i] == [] { continue }
            [h, s, v] = frame[j][i]

            can_draw_outline = outline(i, j) if draw_outline else false

            temp_obj = obj{
                OBJ_ID: 211,
                Z_LAYER: -3,
                Z_ORDER: z_order,
                SCALING: size,
                HVS_ENABLED: true,
                COLOR: _RED_COLOR,
                GROUPS: [_SCENE_GROUP, groups].flatten(),
                HVS: @string(h)+"a"+@string(s/1000)+"a"+@string(v/1000+0.02)+"a0a0",
                X: x_off + i*(30 * (size-0.01)), Y: y_off + j*(30 * (size-0.01)),
            }

            temp_obj.add()

            let outline_obj = ""
            if can_draw_outline {
                outline_obj = obj{
                    OBJ_ID: 211,
                    Z_LAYER: -3,
                    Z_ORDER: z_order-1,
                    SCALING: size*1.2,
                    HVS_ENABLED: true,
                    GROUPS: [_SCENE_GROUP, _IMAGE_OUTLINE_GROUP, groups].flatten(),
                    HVS: "0a0a-100a0a0", // full black
                    X: 3000 + x_off + i*(30 * (size-0.01)), // +3000 for the anti-porn bypass lmao
                    Y: y_off + j*(30 * (size-0.01)),
                }
                outline_obj.add()
            }

            img_objs_to_cache += @string(temp_obj) + @string(outline_obj)
        }
    }

    cached_images[file_name] = img_objs_to_cache.replace("1,211,25,-2,24,"+@string(z_order)+",32,"+@string(size).substr(0, 5)+",41,1,21,4,57,2.", "$")
    // 1. trim big floats to 3 decimal places 
    // 2. make sure every object has group 1001 (if for some reason the compression doesnt work, basically a fallback)
    cached_images[file_name] = cached_images[file_name].replace("(?<=\\.\\d{3})\\d+", "").replace(",57,", ",57,1001.")
     
    $.print(file_name, " added")
}







generate_line_tokens = (line: @string) {
    splitted_strings = line.split("\"")
    if splitted_strings.length % 2 == 0 { throw "invalid string at line"+@string(lines.find(line)) }

    let tokens = []
    if splitted_strings.length > 1 {
        for i in 0..splitted_strings.length {
            if i % 2 == 1 { // if in string
                tokens.push('"' + splitted_strings[i] + '"')
                continue
            }

            // if not in string
            tokens += splitted_strings[i].split(" ")
        }
    } else {
        tokens = line.split(" ")
    }
    
    // count the amount of spaces at the beggining of the line
    let spaces = 0
    for char in tokens {
        if char != "" { break } // yeah
        spaces ++
    }


    return [tokens.filter(el => el != ""), (spaces / TAB_SIZE).round()]
}


let i = 35-300

// this looks so much cleaner
collectable = (target, offset: @number = 0, activate_group: @bool = true) {
    [x_off, y_off] = [300, 13]
    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + offset,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: target,
        PICKUP_MODE: 2, // toggle trigger
        ACTIVATE_GROUP: activate_group,
    })
}


add_section = (x_off: @number = 0, y_off: @number = 0) {    
    collectable(_TEXT_SECTION_GROUPS[-1], activate_group=false)

    _TEXT_SECTION_GROUPS.push(?g)
    $.print("added a section") // $.print("SEX!! ðŸ˜‹ðŸ˜‹ðŸ˜‹")

    collectable(_TEXT_SECTION_GROUPS[-1])
}


split_into_lines = (str: @string) {
    let lines = [""]

    for word in str.split(" ") {
        words ++

        // because gd renders text no matter where it is so we need to toggle every 16384 chars
        // but 2000 words is good enough
        if words % 2000 == 1999 { add_section(300, 13) }

        word_plus_space = word + " "
        if lines[-1].length + word_plus_space.length / 2 >= 57 { lines.push("") }
        lines[-1] += word_plus_space
    }
    
    return lines.join("\n")
}


// good code bro
let hide_show_body_parts_functions = {}
for alpha in [0,1] {
    h = ["hide", "show"][alpha]
    let hide_show_body_parts_functions[h] = {}
    for v in MAIN_CHARACTERS_KEYS {
        let hide_show_body_parts_functions[h][v] = {}
        gr = "head,char,r,l".split(",")
        for j in gr {
            let hide_show_body_parts_functions[h][v][j] = !{ CHARACTERS[v][j+"_group"].toggle_off() } if alpha == 0 else !{ CHARACTERS[v][j+"_group"].toggle_on() }
        }
    }
}


// holy shit this is so ugly
let change_sprite_cached_functions = {}
change_sprite = (char, sprite, x_off: @number = 0, y_off: @number = 0) {
    sprite_pos = sprites.positions[char][sprite]
    sprite_img = sprites.images[char][sprite]
    last_sprite_pos = CHARACTERS[char].sprite_pos

    head_img = sprite_img.get("head", null)
    body_img = sprite_img.get("body", null)
    char_img = sprite_img.get("char", null)
    l_img = sprite_img.get("l", null)
    r_img = sprite_img.get("r", null)

    head_pos = sprite_pos.get("head_pos", null)
    char_pos = sprite_pos.get("char_pos", null)
    l_pos = sprite_pos.get("l_pos", null)
    r_pos = sprite_pos.get("r_pos", null)

    last_head_pos = last_sprite_pos.get("head_pos", 0)
    last_char_pos = last_sprite_pos.get("char_pos", 0)
    last_l_pos = last_sprite_pos.get("l_pos", 0)
    last_r_pos = last_sprite_pos.get("r_pos", 0)

    let to_move = [0]*4 // head, l, r, char
    bypass_offset = -MAIN_CHARACTERS_KEYS.index(char) * 3000


    // text objects are temporary
    if head_pos != null {
        to_move[0] = last_head_pos - head_pos
        
        if head_img != null && !(head_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3, Y: 150 + head_pos*6+15,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].head_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(head_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })

            // special case where natsukis head has a small offset on 3.png and 3b.png
            // without this, natsuki looks "decapitated"
            natsuki_3_off = [(18*0.375), (22/2.4)] if char == "n" && (body_img == "natsuki/3.png" || body_img == "natsuki/3b.png") else [0, 0]
            image(head_img, [CHARACTERS[char].group, CHARACTERS[char].head_group], 90 + bypass_offset - natsuki_3_off[0], 4 + head_pos*6 - natsuki_3_off[1])
            CHARACTERS[char].added_sprites.push(head_img)
        }
    }
    if body_img != null {
        to_move[1] = last_l_pos - l_pos
        
        if !(body_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3, Y: 150 + l_pos*6-15,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].l_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(body_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })
            image(body_img, [CHARACTERS[char].group, CHARACTERS[char].l_group], 90 + bypass_offset, 4 + l_pos*6)
            CHARACTERS[char].added_sprites.push(body_img)
        }
    }
    if char_pos != null {
        to_move[3] = last_char_pos - char_pos
        
        if char_img != null && !(char_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3, Y: 150 + char_pos*6,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].char_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(char_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })
            image(char_img, [CHARACTERS[char].group, CHARACTERS[char].char_group], 90 + bypass_offset, 4 + char_pos*6)
            CHARACTERS[char].added_sprites.push(char_img)
        }
    }
    if l_pos != null {
        to_move[1] = last_l_pos - l_pos
        
        if l_img != null && !(l_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3-15, Y: 150 + l_pos*6-15,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].l_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(l_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })
            image(l_img, [CHARACTERS[char].group, CHARACTERS[char].l_group], 90 + bypass_offset, 4 + l_pos*6)
            CHARACTERS[char].added_sprites.push(l_img)
        }
    }
    if r_pos != null {
        to_move[2] = last_r_pos - r_pos

        if r_img != null && !(r_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3+15, Y: 150 + r_pos*6-15,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].r_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(r_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })
            image(r_img, [CHARACTERS[char].group, CHARACTERS[char].r_group], 90 + bypass_offset, 4 + r_pos*6)
            CHARACTERS[char].added_sprites.push(r_img)
        }
    }

    hide = (str) { collectable(hide_show_body_parts_functions.hide[char][str]) }
    show = (str) { collectable(hide_show_body_parts_functions.show[char][str]) }

    CHARACTERS[char].sprite_pos = { head_pos: last_head_pos, char_pos: last_char_pos, l_pos: last_l_pos, r_pos: last_r_pos }
    if head_pos != null { CHARACTERS[char].sprite_pos.head_pos = head_pos; show("head") } else { hide("head") }
    if char_pos != null { CHARACTERS[char].sprite_pos.char_pos = char_pos; show("char") } else { hide("char") }
    if l_pos != null { CHARACTERS[char].sprite_pos.l_pos = l_pos; show("l") } else { hide("l") }
    if r_pos != null { CHARACTERS[char].sprite_pos.r_pos = r_pos; show("r") } else { hide("r") }


    // add collectable that actually moves the shit up and down weeeeeee :DDD
    move_groups = [CHARACTERS[char].head_group, CHARACTERS[char].l_group, CHARACTERS[char].r_group, CHARACTERS[char].char_group]
    move_group_names = "head_group,l_group,r_group,char_group".split(",")
    to_move_values = to_move

    // $.print(to_move, " \"", sprite, "\"  last: ", last_sprite_pos, "  curr: ", sprite_pos)
    for j in 0..to_move.length {
        if to_move[j] == 0 { continue }

        // this simple thing saves 100 whole groups WHAT
        // sputnix reference
        cache_name = char+"_"+move_group_names[j]+"_"+@string(to_move[j])
        if change_sprite_cached_functions.get(cache_name, null) == null {
            change_sprite_cached_functions[cache_name] = !{ move_groups[j].move(0, to_move[j]*2, 0) }
        }

        collectable(change_sprite_cached_functions[cache_name])
    }
}



say_character = (command, tokens, x_off: @number = 0, y_off: @number = 0, speaker_x_off: @number = 0, speaker_y_off: @number = 0) {
    i+=300

    if tokens.length == 2 { change_sprite(command, tokens[0], x_off, y_off) }

    if current_character == "narrator" { // checks if the last character was the narrator
        // if it was, make the name holder thingy appear
        collectable(_NAME_HOLDER_GROUP)
    }

    current_character = command
    $.add(obj{ // text
        OBJ_ID: 914,
        X: x_off, Y: y_off + i,
        SCALING: 0.57,
        GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1]],
        DONT_FADE: true,
        DONT_ENTER: true,
        TEXT: $.b64encode(split_into_lines(tokens[-1].replace("\\[player\\]", PLAYER_NAME))).replace("/", "_").replace("\\+", "-")
    })
    
    $.add(obj{ // speaker name
        OBJ_ID: 914,
        X: speaker_x_off, Y: speaker_y_off + i,
        SCALING: 0.57,
        GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1]],
        DONT_FADE: true,
        DONT_ENTER: true,
        TEXT: $.b64encode(CHARACTERS[current_character].name).replace("/", "_").replace("\\+", "-")
    })
}


say_narrator = (command, x_off: @number = 0, y_off: @number = 0) {
    i+=300
    
    if current_character != "narrator" { // checks if the last character was the narrator
        // if it wasnt then make the name holder thingy dissappear
        collectable(_NAME_HOLDER_GROUP, activate_group=false)
    }

    current_character = "narrator"
    $.add(obj{ // text
        OBJ_ID: 914,
        X: x_off, Y: y_off + i,
        SCALING: 0.66,
        GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1]],
        DONT_FADE: true,
        DONT_ENTER: true,
        TEXT: $.b64encode(split_into_lines(command.replace('"', "").replace("\\[player\\]", PLAYER_NAME))).replace("/", "_").replace("\\+", "-")
    })
}


set_bg = (bg_name, next_line, x_off: @number = 0, y_off: @number = 0) {
    if current_bg == bg_name { return } // checks if the last bg is the current bg

    wait_time = WITH_TOKEN_WAIT_TIMES.get(next_line[0][1], default=0) if next_line[0][0] == "with" else 0

    temp_func = !{ -> in_scene_transition_counter ++; -> _TEXT_GROUP.alpha(0, 0.25) } // started transition
    temp_group = temp_func.start_group

    change_bgs = !{
        -> _BACKGROUNDS_GROUP.move(0, 100 * BACKGROUNDS.index(current_bg), 0) // move to first bg
        -> _BACKGROUNDS_GROUP.move(0, -100 * BACKGROUNDS.index(bg_name), 0) // move to desired bg
        -> in_scene_transition_counter -- // done transitioning
        -> _TEXT_GROUP.alpha(1, 0)
    }

    // we have to do wait() manually because of the fucking optimizer :skull:
    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 400, Y: 400,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: wait_time,
        TARGET: change_bgs,
    })

    // hide all characters while also hopefully not using too many groups and not breaking the optimizer
    // HOLY SHIT ITS USING 0 GROUPS
    for char in MAIN_CHARACTERS_KEYS {
        if !CHARACTERS[char].visible { continue }
        CHARACTERS[char].visible = false

        $.add(obj{
            OBJ_ID: 1007, // alpha trigger id
            X: 500, Y: 400,
            GROUPS: change_bgs.start_group,
            SPAWN_TRIGGERED: true,
            TARGET: CHARACTERS[char].group,
            DURATION: 0,
            OPACITY: 0,
        })
    }
    // end of hiding all characters

    collectable(temp_func, 300)
    current_bg = bg_name
}


set_scene = (tokens, next_line, x_off: @number = 0, y_off: @number = 0) {
    if tokens[0] == "bg" { // in the first day, tokens[0] is always "bg"
        set_bg(tokens[1], next_line, x_off, y_off)
    }
}



fade_in_bgs_function = !{ // group saving goes brrr
    -> _BACKGROUNDS_GROUP.alpha(1, 0.25)
}

fade_in_scene = (x_off: @number = 0, y_off: @number = 0) {
    collectable(fade_in_bgs_function, 300)
}


create_scene_wiper_thing = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 211, // white block
        X: x_off - (9*30)/2, Y: y_off+90,
        GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
        Z_LAYER: 7,
        SCALING: 10,
        HVS: "0a0a-100a0a0", // full black
        HVS_ENABLED: true,
    })

    $.add(obj{
        OBJ_ID: 211, // white block
        X: x_off + (9*30)/2, Y: y_off+90,
        GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
        Z_LAYER: 7,
        SCALING: 10,
        HVS: "0a0a-100a0a0", // full black
        HVS_ENABLED: true,
    })

    // 2 gradients on the left side
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off - (19*30)/2 - (4*30)/2, Y: y_off + i*(6*30),
            ROTATION: -90,
            GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 6,
            Z_LAYER: 7,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    // 2 gradients on the right side
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + (19*30)/2 + (4*30)/2, Y: y_off + i*(6*30),
            ROTATION: 90,
            GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 6,
            Z_LAYER: 7,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


wipe_left_scene_func = !{ // group saving probably
    -> _WIPE_SCENE_GROUP.move(-460, 0, 0) // move behind the player
    -> _WIPE_SCENE_GROUP.move(460, 0, 1.5, EASE_IN) // move it to the right
}
wipe_left_scene = (x_off: @number = 0, y_off: @number = 0) {
    collectable(wipe_left_scene_func, 300)
}

wipe_left = (x_off: @number = 0, y_off: @number = 0) {
    temp_group = ?g

    // we have to do wait() manually because of the fucking optimizer :skull:
    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 450, Y: 450,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: 0,
        TARGET: !{
            -> _BACKGROUNDS_GROUP.alpha(0, 0.2) // fade out
        },
    })

    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 450, Y: 450,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: 0.2,
        TARGET: fade_in_bgs_function,
    })

    collectable(temp_group, 300)
}


with = (tokens, x_off: @number = 0, y_off: @number = 0) {
    // syncing with the bg happens in the bg change macro
    match tokens[0] {
        =="wipeleft_scene": wipe_left_scene(x_off, y_off),
        =="dissolve_scene_full": fade_in_scene(x_off, y_off),
        =="wipeleft": wipe_left(x_off, y_off), // dont actually wipe left, just fade out and in the bg lmao
    }
}






circle = (x: @number, y: @number, scale: @number) { // generate circle using quarter circle thingies at x, y and scale
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x - 15 * scale, Y: y + 15 * scale,
        SCALING: scale,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 0,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x + 15 * scale, Y: y + 15 * scale,
        SCALING: scale,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 90,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x + 15 * scale, Y: y - 15 * scale,
        SCALING: scale,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 180,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x - 15 * scale, Y: y - 15 * scale,
        SCALING: scale,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: -90,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
}


line = (x: @number, y: @number, rotation: @number = 0) {
    // for loop because quarter circle outlines are 1.667x bigger than 3d lines  
    // plus i dont really care about usage of objects at this scale lmao
    for i in 0..3 {
        $.add(obj{
            OBJ_ID: 507, // 3d line
            X: x, Y: y + 10 - i*0.75, // +10 because of the 3d line being offset
            ROTATION: rotation,
            COLOR: _OUTLINE_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 3,
            Z_ORDER: -1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


vertical_line = (x: @number, y: @number, rotation: @number = 90) {
    // for loop because quarter circle outlines are 1.667x bigger than 3d lines  
    // plus i dont really care about usage of objects at this scale lmao
    for i in 0..3 {
        $.add(obj{
            OBJ_ID: 507, // 3d line
            X: x + 20 - i*0.75, Y: y, // +10 because of the 3d line being offset
            ROTATION: rotation,
            COLOR: _OUTLINE_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 3,
            Z_ORDER: -1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


dialogue_box_outline = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off, Y: y_off,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        Z_LAYER: 3,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    
    for i in 1..14 {
        line(x_off + i*30, y_off)
    }

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off + 30*14, Y: y_off,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 90,
        Z_LAYER: 3,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    vertical_line(x_off - 10 + 30*14, y_off - 30)

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off + 30*14, Y: y_off - 60,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 180,
        Z_LAYER: 3,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        line(x_off + i*30, y_off - 78.5, 180) // weird y because of 3d obj offset
    }

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off, Y: y_off - 60,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: -90,
        Z_LAYER: 3,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    
    vertical_line(x_off - 28.5, y_off - 30, -90)
}


dialogue_box_interior = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off, Y: y_off,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 0,
        Z_LAYER: 1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off,
            COLOR: _COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off + 30*14, Y: y_off,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 90,
        Z_LAYER: 1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 0..14+1 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off - 30,
            COLOR: _COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off + 30*14, Y: y_off - 60,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 180,
        Z_LAYER: 1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off - 60,
            COLOR: _COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off, Y: y_off - 60,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: -90,
        Z_LAYER: 1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
}


dialogue_box_speaker_thing = (x_off: @number = 0, y_off: @number = 0) {
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 1837, // quarter circle thingy
            X: x_off + i*75, Y: y_off - 22.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            COLOR: 1c,
            SCALING: 0.5,
            ROTATION: 90 * i,
            Z_LAYER: 3,
            Z_ORDER: -4,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    for i in 0..4 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + (i+1)*15, Y: y_off - 22.5,
            SCALING: 0.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            Z_LAYER: 3,
            Z_ORDER: -4,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    for i in 0..6 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*15, Y: y_off - 37.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            SCALING: 0.5,
            Z_LAYER: 3,
            Z_ORDER: -4,
            DONT_FADE: true,
            DONT_ENTER: true,
        })

        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + i*15, Y: y_off - 42,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            HVS: "0a0a0.75a0a0", // gray
            HVS_ENABLED: true, 
            SCALING: 0.5,
            Z_LAYER: 3,
            Z_ORDER: -3,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


generate_dialogue_box = () {
    dialogue_box_outline(92, 83)
    dialogue_box_interior(92, 83)
    dialogue_box_speaker_thing(130, 143)

    // // add circle thingies
    // for i in -11..11 { // horizontal
    //     for j in -4..4 { // vertical
    //         circle(300 + i*20 + (j%2+1)*10, j*11, 0.15)
    //     }
    // }
}



generate_borders = (x_off: @number = 0, y_off: @number = 0) {
    // blocks
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off - (18*30)/2 - (6*30)/2 + 5, 
            Y: y_off+180*i,
            GROUPS: [_SCENE_GROUP],
            Z_ORDER: 69,
            SCALING: 6,
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
        })
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + (18*30)/2 + (6*30)/2 - 5, 
            Y: y_off+180*i,
            GROUPS: [_SCENE_GROUP],
            Z_ORDER: 69,
            SCALING: 6,
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
        })
    }

    // 4 gradients each on the left and right side
    for i in 0..4 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off - (18*30)/2 + (2.5/3*2)*30/2 + 5, 
            Y: y_off + i*(2.5*30) - 22.5,
            ROTATION: 90,
            GROUPS: [_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 2.5,
            Z_ORDER: 69,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + (18*30)/2 - (2.5/3*2)*30/2 - 5, 
            Y: y_off + i*(2.5*30) - 22.5,
            ROTATION: -90,
            GROUPS: [_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 2.5,
            Z_ORDER: 69,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}






// group saves

// dont remove the arrows or the optimizer is gonna fuck everything up
// somehow it works without the arrows anyways so thats nice yk (future bombie here idk if thats true so dont do it)
// reoptimized this, probably dont even need it anymore
// hop_funcs = { // this saves a whole 1 group in day 1 :rofl: (it might save more for the whole act)
//     s: !{ -> CHARACTERS.s.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.s.group.move(0, -10, 0.2, EASE_IN) },
//     y: !{ -> CHARACTERS.y.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.y.group.move(0, -10, 0.2, EASE_IN) },
//     n: !{ -> CHARACTERS.n.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.n.group.move(0, -10, 0.2, EASE_IN) },
//     m: !{ -> CHARACTERS.m.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.m.group.move(0, -10, 0.2, EASE_IN) },
// }

hide_char_funcs = { // this saved 30 whole groups WHAT
    s: !{ -> CHARACTERS.s.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.s.group.alpha(0, 0.25) },
    y: !{ -> CHARACTERS.y.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.y.group.alpha(0, 0.25) },
    n: !{ -> CHARACTERS.n.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.n.group.alpha(0, 0.25) },
    m: !{ -> CHARACTERS.m.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.m.group.alpha(0, 0.25) },
}

let transform_cached_functions = {}


//    x*0.125     y/7.2    // move units
//    x*0.375     y/2.4    // obj units
//    x = 18b    y = 10b   // total grid squares (blocks) per each dimension

tcommon = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    cache_name = char+"_tcommon_"+@string(x_pix)+"_"+@string(CHARACTERS[char].visible)
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            -> CHARACTERS[char].group.move(x-pos.x, 50-pos.y, 0.25, EASE_IN)
        } if CHARACTERS[char].visible else !{ 
            // if the character is invisible, move to current position instantly then make it visible
            -> CHARACTERS[char].group.move(x-pos.x, 48-pos.y, 0)
            -> CHARACTERS[char].group.move(0, 2, 0.25, EASE_IN)
            -> CHARACTERS[char].group.alpha(1, 0.25) // placing it here is VERY benefic for the group and obj count, but obviously it stresses the optimizer
        }
    }

    collectable(transform_cached_functions[cache_name], 300)
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 50}
}

tinstant = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    cache_name = char+"_tinstant_"+@string(x_pix)
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{ -> CHARACTERS[char].group.move(x-pos.x, 50-pos.y, 0) }
    }

    collectable(transform_cached_functions[cache_name], 300)

    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 50}
}

focus = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    cache_name = char+"_focus_"+@string(x_pix)+"_"+@string(CHARACTERS[char].visible)
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            -> CHARACTERS[char].group.move(x-pos.x, 55-pos.y, 0.25, EASE_IN)
        } if CHARACTERS[char].visible else !{
            // if the character is invisible, move to current position instantly then make it visible
            -> CHARACTERS[char].group.move(x-pos.x, 53-pos.y, 0)
            -> CHARACTERS[char].group.move(0, 2, 0.25, EASE_IN)
            -> CHARACTERS[char].group.alpha(1, 0.25) // placing it here is VERY benefic for the group and obj count
        }
    }

    collectable(transform_cached_functions[cache_name], 300)
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 55}
}

sink = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    cache_name = char+"_sink_"+@string(x_pix)
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            // removed `x-pos.x` in hopes of reducing group usage when i decide to optimize this
            // after optimizing this, i dont think that impacted anything lmao but im not gonna change it back either way
            -> CHARACTERS[char].group.move(0, 45-pos.y, 0.5, EASE_IN)
        }
    }

    collectable(transform_cached_functions[cache_name], 300)
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 45}
} 

hop = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    // re-optimized this
    // collectable(hop_funcs[char], 300)

    cache_name = char+"_hop"
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            -> CHARACTERS[char].group.move(0, 10, 0.1, EASE_OUT)
            -> CHARACTERS[char].group.move(0, -10, 0.2, EASE_IN)
        }
    }

    collectable(transform_cached_functions[cache_name], 300)

    CHARACTERS[char].visible = true
} 

leftin = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    cache_name = char+"_leftin_"+@string(x_pix)
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            -> CHARACTERS[char].group.move(-37.5-pos.x, 50-pos.y, 0)
            -> CHARACTERS[char].group.move(x, 0, 0.25, EASE_IN)
        }
    }

    collectable(transform_cached_functions[cache_name], 300)

    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: -37.5, y: 50}
}

thide = (char, x_off: @number = 0, y_off: @number = 0) {
    // wont re-optimize this, not worth the max gain of 1 group/character
    // which only happens if the character doesnt thide the entire level
    collectable(hide_char_funcs[char], 300)

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: CHARACTERS[char].pos.x, y: CHARACTERS[char].pos.y - 5}
}

lhide = (char, x_off: @number = 0, y_off: @number = 0) {
    pos = CHARACTERS[char].pos

    cache_name = char+"_lhide"
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] =!{
            CHARACTERS[char].group.move(-37.5 - pos.x, 0, 0.25, EASE_OUT)
        }
    }

    collectable(transform_cached_functions[cache_name], 300)

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: -37.5, y: CHARACTERS[char].pos.y}
}


show_character = (tokens, x_off: @number = 0, y_off: @number = 0) {
    // show sayori 4p zorder 2 at t11 (example command thing)
    // not sure if i currently need zorder so im gonna skip that
    // TODO: wtf apparently `behind` exists as a command token and idk what it does

    char_name = tokens[0] // current character's name
    char = char_name[0] // get the first letter of the character's name
    char_index = tokens.index("at") // get the index of "at"
    char_sprite = null if tokens.length < 2 || tokens[1] in ["at", "zorder", "behind"] else tokens[1] // get the current sprite name, such as "4p"

    if char_sprite != null { change_sprite(char, char_sprite, x_off, y_off) }

    // the characetr gets shown in tcommon() and focus()

    if char_index != null && char_index < tokens.length - 1 {
        transform_type = tokens[char_index + 1]
        
        match transform_type {
            =="t41": tcommon(char, 200, x_off, y_off),
            =="t42": tcommon(char, 493, x_off, y_off),
            =="t43": tcommon(char, 786, x_off, y_off),
            =="t44": tcommon(char, 1080, x_off, y_off),
            =="t31": tcommon(char, 240, x_off, y_off),
            =="t32": tcommon(char, 640, x_off, y_off),
            =="t33": tcommon(char, 1040, x_off, y_off),
            =="t21": tcommon(char, 400, x_off, y_off),
            =="t22": tcommon(char, 880, x_off, y_off),
            =="t11": tcommon(char, 640, x_off, y_off),

            =="i41": tinstant(char, 200, x_off, y_off),
            =="i42": tinstant(char, 493, x_off, y_off),
            =="i43": tinstant(char, 786, x_off, y_off),
            =="i44": tinstant(char, 1080, x_off, y_off),
            =="i31": tinstant(char, 240, x_off, y_off),
            =="i32": tinstant(char, 640, x_off, y_off),
            =="i33": tinstant(char, 1040, x_off, y_off),
            =="i21": tinstant(char, 400, x_off, y_off),
            =="i22": tinstant(char, 880, x_off, y_off),
            =="i11": tinstant(char, 640, x_off, y_off),

            =="f41": focus(char, 200, x_off, y_off),
            =="f42": focus(char, 493, x_off, y_off),
            =="f43": focus(char, 786, x_off, y_off),
            =="f44": focus(char, 1080, x_off, y_off),
            =="f31": focus(char, 240, x_off, y_off),
            =="f32": focus(char, 640, x_off, y_off),
            =="f33": focus(char, 1040, x_off, y_off),
            =="f21": focus(char, 400, x_off, y_off),
            =="f22": focus(char, 880, x_off, y_off),
            =="f11": focus(char, 640, x_off, y_off),

            =="s41": sink(char, 200, x_off, y_off),
            =="s42": sink(char, 493, x_off, y_off),
            =="s43": sink(char, 786, x_off, y_off),
            =="s44": sink(char, 1080, x_off, y_off),
            =="s31": sink(char, 240, x_off, y_off),
            =="s32": sink(char, 640, x_off, y_off),
            =="s33": sink(char, 1040, x_off, y_off),
            =="s21": sink(char, 400, x_off, y_off),
            =="s22": sink(char, 880, x_off, y_off),
            =="s11": sink(char, 640, x_off, y_off),

            =="h41": hop(char, 200, x_off, y_off),
            =="h42": hop(char, 493, x_off, y_off),
            =="h43": hop(char, 786, x_off, y_off),
            =="h44": hop(char, 1080, x_off, y_off),
            =="h31": hop(char, 240, x_off, y_off),
            =="h32": hop(char, 640, x_off, y_off),
            =="h33": hop(char, 1040, x_off, y_off),
            =="h21": hop(char, 400, x_off, y_off),
            =="h22": hop(char, 880, x_off, y_off),
            =="h11": hop(char, 640, x_off, y_off),

            =="l41": leftin(char, 200, x_off, y_off),
            =="l42": leftin(char, 493, x_off, y_off),
            =="l43": leftin(char, 786, x_off, y_off),
            =="l44": leftin(char, 1080, x_off, y_off),
            =="l31": leftin(char, 240, x_off, y_off),
            =="l32": leftin(char, 640, x_off, y_off),
            =="l33": leftin(char, 1040, x_off, y_off),
            =="l21": leftin(char, 400, x_off, y_off),
            =="l22": leftin(char, 880, x_off, y_off),
            =="l11": leftin(char, 640, x_off, y_off),

            =="thide": thide(char, x_off, y_off),
            =="lhide": lhide(char, x_off, y_off),
        }
    }
}

hide_character = (tokens, x_off: @number = 0, y_off: @number = 0) {
    char = tokens[0][0]
    if CHARACTERS[char].visible == false { return }

    collectable(hide_char_funcs[char], 300)

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: CHARACTERS[char].pos.x, y: CHARACTERS[char].pos.y - 5}
}



python_single_line = (tokens) {
    // return if the line is not setting a variable (change later)
    if !("=" in tokens) { return }
    variable = tokens[0]
    value = tokens[2]

    // s_name = "Sayori"
    if variable.substr(1, 6) == "_name" { // if it sets someone's name
        CHARACTERS[variable[0]].name = value.replace('"', "").replace("'", "")
    }
}


let labels = {}
call_label = (label_name: @string) {
    let current_code_blocks = []
    let i_line = 0
    for line in labels[label_name] {
        [__tokens, tabs] = labels[label_name][i_line]
    
        command = __tokens[0]
        if !(command in TOKENS) && command[0] != '"' { i_line ++; continue } // if its not a valid token/word
        tokens = __tokens[1:] // remove the command bit from tokens

        if command == "return" { break }

        match command {
            in CHARACTERS_TOKENS: say_character(command, tokens, 300, 15, 169, 75),
            =="scene": set_scene(tokens, labels[label_name][i_line+1], 300, 13),
            =="show": show_character(tokens, 300, 13),
            =="hide": hide_character(tokens, 300, 13),
            =="$": python_single_line(tokens),
            =="with": with(tokens, 300, 13),
            =="call": call_label(tokens[0]),
        }
        
        // if narrator
        if command[0] == "\"" && tokens.length == 0 {
            say_narrator(command, 300, 13)
        }
    
        // doing it like this cuz u cant break in a match statement lmao
        // im gonna change this later so it just resumes instead of breaking
        if command == "call" { break }

        // $.print(modified_line)
        i_line ++
    }
}











create_scene_wiper_thing(1000, 60)
// make bg invisible
$.add(obj{
    OBJ_ID: 1007, // alpha trigger
    X: -45, Y: 369,
    TARGET: _BACKGROUNDS_GROUP,
    OPACITY: 0,
    DURATION: 0,
})


// placeholder colors, remove this later
character_colors = ["195a0.8a0.96a0a0", "125a0.59a0.78a0a0", "304a0.53a0.95a0a0", "281a0.80a0.96a0a0"]

// generate and add characers
for i in 0..MAIN_CHARACTERS_KEYS.length {
    // // placeholder
    // $.add(obj{
    //     OBJ_ID: 211, // white block
    //     X: 80*3, Y: 150,
    //     GROUPS: [CHARACTERS[MAIN_CHARACTERS_KEYS[i]].group, _SCENE_GROUP],
    //     COLOR: _RED_COLOR,
    //     HVS: character_colors[i],
    //     HVS_ENABLED: true,
    //     SCALING: 4,
    //     Z_LAYER: -2,
    //     DONT_FADE: true,
    //     DONT_ENTER: true,
    // })

    // alpha = 0 at the start to hide the characters
    $.add(obj{
        OBJ_ID: 1007, // alpha trigger
        X: -45, Y: 420,
        TARGET: CHARACTERS[MAIN_CHARACTERS_KEYS[i]].group,
        OPACITY: 0,
        DURATION: 0,
    })
}

// generate and add all bgs
for bg in 0..BACKGROUNDS.length {
    // jpeg(bg+".png", 42, 0)
    _BG_GROUPS.push(@group(998 - _BG_GROUPS.length))
    image(BACKGROUND_FILE_NAMES[bg], [_BG_GROUPS[-1], _BACKGROUNDS_GROUP], 42, 4 + (_BG_GROUPS.length-1)*300, -20, false)
}

// all labels, custom for loop
// let labels = {} // moved to just before call_label()
let line_idx_for_labels = 0
while line_idx_for_labels < lines.length - 1 {
    if !("label" in lines[line_idx_for_labels]) { line_idx_for_labels ++; continue }

    // we already know the line starts with "label" so we can just gen the tokens
    [__tokens, label_tabs] = generate_line_tokens(lines[line_idx_for_labels])

    if __tokens[0] != "label" { line_idx_for_labels ++; continue } // if the command isnt "label", aka if we found it in a character dialogue or smth
    label_name = __tokens[1].split(":")[0] // to remove the colon that the lexer didnt remove

    if label_name in LABELS_EXCLUSION_LIST { line_idx_for_labels ++; continue }

    req_tabs = label_tabs + 1

    let labels[label_name] = []

    // check if its in the current label & pregenerate the line tokens while doing so
    let i_line = line_idx_for_labels
    for line in lines[line_idx_for_labels + 1:] { // this might be wrong
        if line.length == 0 { line_idx_for_labels ++; i_line ++; continue } // skip empty lines

        [tokens, tabs] = generate_line_tokens(line)
        if tabs < req_tabs { line_idx_for_labels = i_line; break } // not in the current label
        // if tokens[0] == "return" { break } // moved to call_label()
        labels[label_name].push([tokens, tabs])
        i_line ++
    }
    
    if label_name == "ch0_main" { call_label(label_name) }
}

$.add(obj{ // follow player
    OBJ_ID: 901, // move trigger id
    X: 225, Y: -135,
    TARGET: _SCENE_GROUP,
    MOVE_X: PLAYER_SPEED*30*LEVEL_DURATION, // move to player
    DURATION: LEVEL_DURATION,
})

$.add(obj{ // so the level is long enough or something
    OBJ_ID: 1,
    X: PLAYER_SPEED*30*LEVEL_DURATION, Y: -69,
})

$.add(obj{ // add invisible trigger at the start
    OBJ_ID: 1007, // alpha trigger id
    X: -31, Y: -69,
    TARGET: _INVISIBLE_GROUP,
    OPACITY: 0,
    DURATION: 0,
})


change_dialog = !{ // change through dialog boxes
    if in_scene_transition_counter == 0 {
        _TEXT_GROUP.move(0, -100, 0)
    }
}

// gonna change soom
on(gs.button_a(), change_dialog)
on(gs.button_b(), change_dialog)

generate_dialogue_box()
generate_borders(302, 60)

 // anti-porn bypass or whatever lmao
_IMAGE_OUTLINE_GROUP.move(-1000, 0, 0)
for i in 0..MAIN_CHARACTERS_KEYS.length {
    CHARACTERS[MAIN_CHARACTERS_KEYS[i]].group.move(1000*i, 0, 0)
}

if CACHE_IMAGES { $.writefile("./cache_output.txt", "{"+cached_images.map((k, v) => '"'+k+"\": \""+v+'"').join(", ")+"}") }
$.print("words: ", words)
