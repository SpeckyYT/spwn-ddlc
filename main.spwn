gs = import gamescene
sprites = import "sprites.spwn"
extract obj_props

lines = $.readfile("./ddlc-decompiled/scripts.rpa/script-ch0.rpy").split("\r\n")

PLAYER_NAME = "bombie"

_TEXT_GROUP = ?g
_WIPE_SCENE_GROUP = ?g
_NAME_HOLDER_GROUP = ?g
_INVISIBLE_GROUP = ?g
let _TEXT_SECTION_GROUPS = [?g]

// these are static because of the image caching thing
_BACKGROUNDS_GROUP = 1g
_SCENE_GROUP = 2g
let _BG_GROUPS = []

_COLOR = 2c
_OUTLINE_COLOR = 1c
_CIRCLE_COLOR = 3c
_RED_COLOR = 4c // this needs to be static in order for image cache to work

PLAYER_SPEED = 8.3705 // slow speed
LEVEL_DURATION = 10 * 60 // seconds
TAB_SIZE = 4

GENERATE_IMAGES = true
CACHE_IMAGES = true
READ_CACHED_IMAGES = true // disable this if you dont have a file named "./cached_output.txt" that you didnt make

let CHARACTERS = {
    narrator: { name: "", },
    s: { name:    "???", pos: {x: 80, y: 50}, group: ?g, visible: false, head_group: ?g, l_group: ?g, r_group: ?g, sprite: "", },
    m: { name: "Girl 3", pos: {x: 80, y: 50}, group: ?g, visible: false, head_group: ?g, l_group: ?g, r_group: ?g, sprite: "", },
    n: { name: "Girl 2", pos: {x: 80, y: 50}, group: ?g, visible: false, head_group: ?g, l_group: ?g, r_group: ?g, sprite: "", },
    y: { name: "Girl 1", pos: {x: 80, y: 50}, group: ?g, visible: false, head_group: ?g, l_group: ?g, r_group: ?g, sprite: "", },
    ny: { name: "Nat & Yuri", },
    mc: { name:  PLAYER_NAME, },
}

MAIN_CHARACTERS_KEYS = ["s", "m", "n", "y"]
CHARACTERS_TOKENS = ["narrator", "s", "m", "n", "y", "ny", "mc"]
CHARACTERS_NAMES = [" *empty* ", "Sayori", "Yuri", "Monika", "Natsuki", "Nat & Yuri", PLAYER_NAME]
BACKGROUNDS = ["residential_day", "class_day", "club_day", "corridor"]
BACKGROUND_FILE_NAMES = ["bg/residential.png", "bg/class.png", "bg/club.png", "bg/corridor.png"]

LABELS_EXCLUSION_LIST = ["ch0_kill"]
WITH_TOKEN_WAIT_TIMES = {"wipeleft_scene": 1, "wipeleft": 0.2}

TOKENS = ["scene", CHARACTERS_TOKENS, "$", "show", "hide", "with"].flatten()

let current_character = "your mother"
let current_bg = "residential_day"
let words = 0

in_scene_transition_counter = counter(false)



let cached_bgs = {}
readed_cached_images = $.readfile("./cache_output.txt", "json") if READ_CACHED_IMAGES else {} // misspelled ikik but it makes more sense than "read"
image_output = match GENERATE_IMAGES { ==true: $.readfile("./output.txt", "json") }

image = (file_name: @string, group: @group, x_off: @number = 0, y_off: @number = 0) {
    if GENERATE_IMAGES == false { return }

    if CACHE_IMAGES { let cached_bgs[file_name] = "" }
    frame = image_output[file_name].reverse()

    if READ_CACHED_IMAGES && readed_cached_images.get(file_name, default=null) != null {
        $.add(obj{HVS: ";"+readed_cached_images[file_name].replace("\\$", "1,211,24,-42,25,-2,32,0.335,41,1,21,4,57,1.2.1001.")+"1,1,2,-999"})
        cached_bgs[file_name] += readed_cached_images[file_name]

        $.print(file_name, " added from cache")
        return
    }

    let bg_objs_to_cache = ""
    for j in 0..frame.length {
        for i in frame[j].length..0 {
            [h, s, v] = frame[j][i]

            temp_obj = obj{
                OBJ_ID: 211,
                Z_LAYER: -42,
                Z_ORDER: -2,
                SCALING: 0.3345,
                HVS_ENABLED: true,
                COLOR: _RED_COLOR,
                GROUPS: [_BACKGROUNDS_GROUP, _SCENE_GROUP, group],
                HVS: @string(h)+"a"+@string(s/1000)+"a"+@string(v/1000+0.02)+"a0a0",
                X: x_off + i*10, Y: y_off + j*10 + (_BG_GROUPS.length-1)*300,
            }

            temp_obj.add()
            bg_objs_to_cache += @string(temp_obj)
        }
    }
    cached_bgs[file_name] = bg_objs_to_cache.replace("1,211,24,-42,25,-2,32,0\\.335,41,1,21,4,57,1\\.2\\.", "$").replace("(?<=\\.\\d{3})\\d+", "")
    $.print(file_name, " added")
}








generate_line_tokens = (line: @string) {
    splitted_strings = line.split("\"")
    if splitted_strings.length % 2 == 0 { throw "invalid string at line"+@string(lines.find(line)) }

    let tokens = []
    if splitted_strings.length > 1 {
        for i in 0..splitted_strings.length {
            if i % 2 == 1 { // if in string
                tokens.push('"' + splitted_strings[i] + '"')
                continue
            }

            // if not in string
            tokens += splitted_strings[i].split(" ")
        }
    } else {
        tokens = line.split(" ")
    }
    
    // count the amount of spaces at the beggining of the line
    let spaces = 0
    for char in tokens {
        if char != "" { break } // yeah
        spaces ++
    }


    return [tokens.filter(el => el != ""), (spaces / TAB_SIZE).round()]
}


let i = 35-300

add_section = (x_off: @number = 0, y_off: @number = 0) {
    // because gd renders text no matter where it is so we need to toggle every 16384 chars
    // but 2222 words is good enough
    if words % 2222 == 2221 {
        $.add(obj{
            OBJ_ID: 1614, // collectable id
            X: x_off, Y: y_off + i,
            GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
            SCALING: 6,
            TARGET: _TEXT_SECTION_GROUPS[-1],
            PICKUP_MODE: 2, // toggle trigger
            ACTIVATE_GROUP: false, // off
        })

        _TEXT_SECTION_GROUPS.push(?g)
        $.print("added a section") // $.print("SEX!! ðŸ˜‹ðŸ˜‹ðŸ˜‹")

        $.add(obj{
            OBJ_ID: 1614, // collectable id
            X: x_off, Y: y_off + i,
            GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
            SCALING: 6,
            TARGET: _TEXT_SECTION_GROUPS[-1],
            PICKUP_MODE: 2, // toggle trigger
            ACTIVATE_GROUP: true, // on
        })
    }
}


split_into_lines = (str: @string) {
    let lines = [""]

    for word in str.split(" ") {
        words ++
        add_section(300, 13)

        word_plus_space = word + " "
        if lines[-1].length + word_plus_space.length / 2 >= 57 { lines.push("") }
        lines[-1] += word_plus_space
    }
    
    return lines.join("\n")
}



say_character = (command, tokens, x_off: @number = 0, y_off: @number = 0, speaker_x_off: @number = 0, speaker_y_off: @number = 0) {
    i+=300

    if current_character == "narrator" { // checks if the last character was the narrator
        // if it was, make the name holder thingy appear
        $.add(obj{
            OBJ_ID: 1614, // collectable id
            X: x_off, Y: y_off + i,
            GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
            SCALING: 6,
            TARGET: _NAME_HOLDER_GROUP,
            PICKUP_MODE: 2, // toggle trigger
            ACTIVATE_GROUP: true, // on
        })
    }

    current_character = command
    $.add(obj{ // text
        OBJ_ID: 914,
        X: x_off, Y: y_off + i,
        SCALING: 0.57,
        GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1]],
        DONT_FADE: true,
        DONT_ENTER: true,
        TEXT: $.b64encode(split_into_lines(tokens[-1].replace("\\[player\\]", PLAYER_NAME))).replace("/", "_").replace("\\+", "-")
    })
    
    $.add(obj{ // speaker name
        OBJ_ID: 914,
        X: speaker_x_off, Y: speaker_y_off + i,
        SCALING: 0.57,
        GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1]],
        DONT_FADE: true,
        DONT_ENTER: true,
        TEXT: $.b64encode(CHARACTERS[current_character].name).replace("/", "_").replace("\\+", "-")
    })
}


say_narrator = (command, x_off: @number = 0, y_off: @number = 0) {
    i+=300
    
    if current_character != "narrator" { // checks if the last character was the narrator
        // if it wasnt then make the name holder thingy dissappear
        $.add(obj{
            OBJ_ID: 1614, // collectable id
            X: x_off, Y: y_off + i,
            GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
            SCALING: 6,
            TARGET: _NAME_HOLDER_GROUP,
            PICKUP_MODE: 2, // toggle trigger
            ACTIVATE_GROUP: false, // on
        })
    }

    current_character = "narrator"
    $.add(obj{ // text
        OBJ_ID: 914,
        X: x_off, Y: y_off + i,
        SCALING: 0.66,
        GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1]],
        DONT_FADE: true,
        DONT_ENTER: true,
        TEXT: $.b64encode(split_into_lines(command.replace('"', "").replace("\\[player\\]", PLAYER_NAME))).replace("/", "_").replace("\\+", "-")
    })
}


set_bg = (bg_name, next_line, x_off: @number = 0, y_off: @number = 0) {
    if current_bg == bg_name { return } // checks if the last bg is the current bg

    wait_time = WITH_TOKEN_WAIT_TIMES.get(next_line[0][1], default=0) if next_line[0][0] == "with" else 0

    temp_func = !{ -> in_scene_transition_counter ++; -> _TEXT_GROUP.alpha(0, 0.25) } // started transition
    temp_group = temp_func.start_group

    change_bgs = !{
        -> _BACKGROUNDS_GROUP.move(0, 100 * BACKGROUNDS.index(current_bg), 0) // move to first bg
        -> _BACKGROUNDS_GROUP.move(0, -100 * BACKGROUNDS.index(bg_name), 0) // move to desired bg
        -> in_scene_transition_counter -- // done transitioning
        -> _TEXT_GROUP.alpha(1, 0)
    }

    // we have to do wait() manually because of the fucking optimizer :skull:
    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 400, Y: 400,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: wait_time,
        TARGET: change_bgs,
    })

    // hide all characters while also hopefully not using too many groups and not breaking the optimizer
    // HOLY SHIT ITS USING 0 GROUPS
    for char in MAIN_CHARACTERS_KEYS {
        if !CHARACTERS[char].visible { continue }
        CHARACTERS[char].visible = false

        $.add(obj{
            OBJ_ID: 1007, // alpha trigger id
            X: 500, Y: 400,
            GROUPS: change_bgs.start_group,
            SPAWN_TRIGGERED: true,
            TARGET: CHARACTERS[char].group,
            DURATION: 0,
            OPACITY: 0,
        })
    }
    // end of hiding all characters

    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: temp_func,
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })

    current_bg = bg_name
}


set_scene = (tokens, next_line, x_off: @number = 0, y_off: @number = 0) {
    if tokens[0] == "bg" { // in the first day, tokens[0] is always "bg"
        set_bg(tokens[1], next_line, x_off, y_off)
    }
}



fade_in_bgs_function = !{ // group saving goes brrr
    -> _BACKGROUNDS_GROUP.alpha(1, 0.25)
}

fade_in_scene = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: fade_in_bgs_function,
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })
}


create_scene_wiper_thing = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 211, // white block
        X: x_off - (9*30)/2, Y: y_off+90,
        GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
        Z_LAYER: 42,
        SCALING: 10,
        HVS: "0a0a-100a0a0", // full black
        HVS_ENABLED: true,
    })

    $.add(obj{
        OBJ_ID: 211, // white block
        X: x_off + (9*30)/2, Y: y_off+90,
        GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
        Z_LAYER: 42,
        SCALING: 10,
        HVS: "0a0a-100a0a0", // full black
        HVS_ENABLED: true,
    })

    // 2 gradients on the left side
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off - (19*30)/2 - (4*30)/2, Y: y_off + i*(6*30),
            ROTATION: -90,
            GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 6,
            Z_LAYER: 42,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    // 2 gradients on the right side
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + (19*30)/2 + (4*30)/2, Y: y_off + i*(6*30),
            ROTATION: 90,
            GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 6,
            Z_LAYER: 42,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


wipe_left_scene = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: !{
            -> _WIPE_SCENE_GROUP.move(-460, 0, 0) // move behind the player
            -> _WIPE_SCENE_GROUP.move(460, 0, 1.5, EASE_IN) // move it to the right
        },
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })
}

wipe_left = (x_off: @number = 0, y_off: @number = 0) {
    temp_group = ?g

    // we have to do wait() manually because of the fucking optimizer :skull:
    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 450, Y: 450,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: 0,
        TARGET: !{
            -> _BACKGROUNDS_GROUP.alpha(0, 0.2) // fade out
        },
    })

    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 450, Y: 450,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: 0.2,
        TARGET: fade_in_bgs_function,
    })

    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: temp_group,
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })
}


with = (tokens, x_off: @number = 0, y_off: @number = 0) {
    // syncing with the bg happens in the bg change macro
    match tokens[0] {
        =="wipeleft_scene": wipe_left_scene(x_off, y_off),
        =="dissolve_scene_full": fade_in_scene(x_off, y_off),
        =="wipeleft": wipe_left(x_off, y_off), // dont actually wipe left, just fade out and in the bg lmao
    }
}






circle = (x: @number, y: @number, scale: @number) { // generate circle using quarter circle thingies at x, y and scale
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x - 15 * scale, Y: y + 15 * scale,
        SCALING: scale,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 0,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x + 15 * scale, Y: y + 15 * scale,
        SCALING: scale,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 90,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x + 15 * scale, Y: y - 15 * scale,
        SCALING: scale,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 180,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x - 15 * scale, Y: y - 15 * scale,
        SCALING: scale,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: -90,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
}


line = (x: @number, y: @number, rotation: @number = 0) {
    // for loop because quarter circle outlines are 1.667x bigger than 3d lines  
    // plus i dont really care about usage of objects at this scale lmao
    for i in 0..3 {
        $.add(obj{
            OBJ_ID: 507, // 3d line
            X: x, Y: y + 10 - i*0.75, // +10 because of the 3d line being offset
            ROTATION: rotation,
            COLOR: _OUTLINE_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 2,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


vertical_line = (x: @number, y: @number, rotation: @number = 90) {
    // for loop because quarter circle outlines are 1.667x bigger than 3d lines  
    // plus i dont really care about usage of objects at this scale lmao
    for i in 0..3 {
        $.add(obj{
            OBJ_ID: 507, // 3d line
            X: x + 20 - i*0.75, Y: y, // +10 because of the 3d line being offset
            ROTATION: rotation,
            COLOR: _OUTLINE_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 2,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


dialogue_box_outline = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off, Y: y_off,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        Z_LAYER: 2,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    
    for i in 1..14 {
        line(x_off + i*30, y_off)
    }

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off + 30*14, Y: y_off,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 90,
        Z_LAYER: 2,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    vertical_line(x_off - 10 + 30*14, y_off - 30)

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off + 30*14, Y: y_off - 60,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 180,
        Z_LAYER: 2,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        line(x_off + i*30, y_off - 78.5, 180) // weird y because of 3d obj offset
    }

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off, Y: y_off - 60,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: -90,
        Z_LAYER: 2,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    
    vertical_line(x_off - 28.5, y_off - 30, -90)
}


dialogue_box_interior = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off, Y: y_off,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 0,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off,
            COLOR: _COLOR,
            GROUPS: _SCENE_GROUP,
            Z_ORDER: -1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off + 30*14, Y: y_off,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 90,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 0..14+1 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off - 30,
            COLOR: _COLOR,
            GROUPS: _SCENE_GROUP,
            Z_ORDER: -1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off + 30*14, Y: y_off - 60,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 180,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off - 60,
            COLOR: _COLOR,
            GROUPS: _SCENE_GROUP,
            Z_ORDER: -1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off, Y: y_off - 60,
        COLOR: _COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: -90,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
}


dialogue_box_speaker_thing = (x_off: @number = 0, y_off: @number = 0) {
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 1837, // quarter circle thingy
            X: x_off + i*75, Y: y_off - 22.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            COLOR: 1c,
            SCALING: 0.5,
            ROTATION: 90 * i,
            Z_ORDER: -2,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    for i in 0..4 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + (i+1)*15, Y: y_off - 22.5,
            SCALING: 0.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            Z_ORDER: -2,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    for i in 0..6 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*15, Y: y_off - 37.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            SCALING: 0.5,
            Z_ORDER: -2,
            DONT_FADE: true,
            DONT_ENTER: true,
        })

        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + i*15, Y: y_off - 42,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            HVS: "0a0a0.75a0a0", // gray
            HVS_ENABLED: true, 
            SCALING: 0.5,
            Z_ORDER: -1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


generate_dialogue_box = () {
    dialogue_box_outline(92, 83)
    dialogue_box_interior(92, 83)
    dialogue_box_speaker_thing(130, 143)

    // // add circle thingies
    // for i in -11..11 { // horizontal
    //     for j in -4..4 { // vertical
    //         circle(300 + i*20 + (j%2+1)*10, j*11, 0.15)
    //     }
    // }
}



generate_borders = (x_off: @number = 0, y_off: @number = 0) {
    // blocks
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off - (18*30)/2 - (6*30)/2 + 5, 
            Y: y_off+180*i,
            GROUPS: [_SCENE_GROUP],
            Z_LAYER: 69,
            SCALING: 6,
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
        })
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + (18*30)/2 + (6*30)/2 - 5, 
            Y: y_off+180*i,
            GROUPS: [_SCENE_GROUP],
            Z_LAYER: 69,
            SCALING: 6,
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
        })
    }

    // 4 gradients each on the left and right side
    for i in 0..4 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off - (18*30)/2 + (2.5/3*2)*30/2 + 5, 
            Y: y_off + i*(2.5*30) - 22.5,
            ROTATION: 90,
            GROUPS: [_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 2.5,
            Z_LAYER: 69,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + (18*30)/2 - (2.5/3*2)*30/2 - 5, 
            Y: y_off + i*(2.5*30) - 22.5,
            ROTATION: -90,
            GROUPS: [_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 2.5,
            Z_LAYER: 69,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}






// group saves

// dont remove the arrows or the optimizer is gonna fuck everything up
// somehow it works without the arrows anyways so thats nice yk (future bombie here idk if thats true so dont do it)
hop_funcs = { // this saves a whole 1 group in day 1 :rofl: (it might save more for the whole act)
    s: !{ -> CHARACTERS.s.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.s.group.move(0, -10, 0.2, EASE_IN) },
    y: !{ -> CHARACTERS.y.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.y.group.move(0, -10, 0.2, EASE_IN) },
    n: !{ -> CHARACTERS.n.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.n.group.move(0, -10, 0.2, EASE_IN) },
    m: !{ -> CHARACTERS.m.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.m.group.move(0, -10, 0.2, EASE_IN) },
}

hide_char_funcs = { // this saved 30 whole groups WHAT
    s: !{ -> CHARACTERS.s.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.s.group.alpha(0, 0.25) },
    y: !{ -> CHARACTERS.y.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.y.group.alpha(0, 0.25) },
    n: !{ -> CHARACTERS.n.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.n.group.alpha(0, 0.25) },
    m: !{ -> CHARACTERS.m.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.m.group.alpha(0, 0.25) },
}



//    x*0.125     y/7.2    // move units
//    x*0.375     y/2.4    // obj units
//    x = 18b    y = 10b   // total grid squares (blocks) per each dimension

tcommon = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    if CHARACTERS[char].visible {
        $.add(obj{
            OBJ_ID: 1614, // collectable id
            X: x_off, Y: y_off + i + 300,
            GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
            SCALING: 6,
            TARGET: !{
                -> CHARACTERS[char].group.move(x-pos.x, 50-pos.y, 0.25, EASE_IN)
            },
            PICKUP_MODE: 2, // toggle
            ACTIVATE_GROUP: true, // on
        })
    } else { // if the character is invisible, move to current position instantly then make it visible
        $.add(obj{
            OBJ_ID: 1614, // collectable id
            X: x_off, Y: y_off + i + 300,
            GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
            SCALING: 6,
            TARGET: !{
                -> CHARACTERS[char].group.move(x-pos.x, 48-pos.y, 0)
                -> CHARACTERS[char].group.move(0, 2, 0.25, EASE_IN)
                -> CHARACTERS[char].group.alpha(1, 0.25) // placing it here is VERY benefic for the group and obj count
            },
            PICKUP_MODE: 2, // toggle
            ACTIVATE_GROUP: true, // on
        })
    }
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 50}
}

tinstant = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: !{
            -> CHARACTERS[char].group.move(x-pos.x, 50-pos.y, 0)
        },
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 50}
}

focus = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    if CHARACTERS[char].visible {
        $.add(obj{
            OBJ_ID: 1614, // collectable id
            X: x_off, Y: y_off + i + 300,
            GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
            SCALING: 6,
            TARGET: !{
                -> CHARACTERS[char].group.move(x-pos.x, 55-pos.y, 0.25, EASE_IN)
            },
            PICKUP_MODE: 2, // toggle
            ACTIVATE_GROUP: true, // on
        })
    } else { // if the character is invisible, move to current position instantly then make it visible
        $.add(obj{
            OBJ_ID: 1614, // collectable id
            X: x_off, Y: y_off + i + 300,
            GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
            SCALING: 6,
            TARGET: !{
                -> CHARACTERS[char].group.move(x-pos.x, 53-pos.y, 0)
                -> CHARACTERS[char].group.move(0, 2, 0.25, EASE_IN)
                -> CHARACTERS[char].group.alpha(1, 0.25) // placing it here is VERY benefic for the group and obj count
                // past bombie, where else would you place it :skull:
            },
            PICKUP_MODE: 2, // toggle
            ACTIVATE_GROUP: true, // on
        })
    }
    
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 55}
}

sink = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: !{
            // removed `x-pos.x` in hopes of reducing group usage when i decide to optimize this
            -> CHARACTERS[char].group.move(0, 45-pos.y, 0.5, EASE_IN)
        },
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 45}
} 

hop = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: hop_funcs[char],
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })

    CHARACTERS[char].visible = true
} 

leftin = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.125
    pos = CHARACTERS[char].pos

    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: !{
            -> CHARACTERS[char].group.move(-37.5-pos.x, 50-pos.y, 0)
            -> CHARACTERS[char].group.move(x, 0, 0.25, EASE_IN)
        },
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: -37.5, y: 50}
}

thide = (char, x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: hide_char_funcs[char],
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: CHARACTERS[char].pos.x, y: CHARACTERS[char].pos.y - 5}
}

lhide = (char, x_off: @number = 0, y_off: @number = 0) {
    pos = CHARACTERS[char].pos

    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: !{
            CHARACTERS[char].group.move(-37.5 - pos.x, 0, 0.25, EASE_OUT)
        },
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: -37.5, y: CHARACTERS[char].pos.y}
}


change_sprite = (char, sprite) {
    
}


show_character = (tokens, x_off: @number = 0, y_off: @number = 0) {
    // show sayori zorder 1 at thide (example command thing)
    // not sure if i currently need zorder so im gonna skip that

    char_name = tokens[0] // current character's name
    char = char_name[0] // get the first letter of the character's name
    char_index = tokens.index("at") // get the index of "at"

    // the characetr gets shown in tcommon() and focus()

    if char_index != null && char_index < tokens.length - 1 {
        transform_type = tokens[char_index + 1]
        
        match transform_type {
            =="t41": tcommon(char, 200, x_off, y_off),
            =="t42": tcommon(char, 493, x_off, y_off),
            =="t43": tcommon(char, 786, x_off, y_off),
            =="t44": tcommon(char, 1080, x_off, y_off),
            =="t31": tcommon(char, 240, x_off, y_off),
            =="t32": tcommon(char, 640, x_off, y_off),
            =="t33": tcommon(char, 1040, x_off, y_off),
            =="t21": tcommon(char, 400, x_off, y_off),
            =="t22": tcommon(char, 880, x_off, y_off),
            =="t11": tcommon(char, 640, x_off, y_off),

            =="i41": tinstant(char, 200, x_off, y_off),
            =="i42": tinstant(char, 493, x_off, y_off),
            =="i43": tinstant(char, 786, x_off, y_off),
            =="i44": tinstant(char, 1080, x_off, y_off),
            =="i31": tinstant(char, 240, x_off, y_off),
            =="i32": tinstant(char, 640, x_off, y_off),
            =="i33": tinstant(char, 1040, x_off, y_off),
            =="i21": tinstant(char, 400, x_off, y_off),
            =="i22": tinstant(char, 880, x_off, y_off),
            =="i11": tinstant(char, 640, x_off, y_off),

            =="f41": focus(char, 200, x_off, y_off),
            =="f42": focus(char, 493, x_off, y_off),
            =="f43": focus(char, 786, x_off, y_off),
            =="f44": focus(char, 1080, x_off, y_off),
            =="f31": focus(char, 240, x_off, y_off),
            =="f32": focus(char, 640, x_off, y_off),
            =="f33": focus(char, 1040, x_off, y_off),
            =="f21": focus(char, 400, x_off, y_off),
            =="f22": focus(char, 880, x_off, y_off),
            =="f11": focus(char, 640, x_off, y_off),

            =="s41": sink(char, 200, x_off, y_off),
            =="s42": sink(char, 493, x_off, y_off),
            =="s43": sink(char, 786, x_off, y_off),
            =="s44": sink(char, 1080, x_off, y_off),
            =="s31": sink(char, 240, x_off, y_off),
            =="s32": sink(char, 640, x_off, y_off),
            =="s33": sink(char, 1040, x_off, y_off),
            =="s21": sink(char, 400, x_off, y_off),
            =="s22": sink(char, 880, x_off, y_off),
            =="s11": sink(char, 640, x_off, y_off),

            =="h41": hop(char, 200, x_off, y_off),
            =="h42": hop(char, 493, x_off, y_off),
            =="h43": hop(char, 786, x_off, y_off),
            =="h44": hop(char, 1080, x_off, y_off),
            =="h31": hop(char, 240, x_off, y_off),
            =="h32": hop(char, 640, x_off, y_off),
            =="h33": hop(char, 1040, x_off, y_off),
            =="h21": hop(char, 400, x_off, y_off),
            =="h22": hop(char, 880, x_off, y_off),
            =="h11": hop(char, 640, x_off, y_off),

            =="l41": leftin(char, 200, x_off, y_off),
            =="l42": leftin(char, 493, x_off, y_off),
            =="l43": leftin(char, 786, x_off, y_off),
            =="l44": leftin(char, 1080, x_off, y_off),
            =="l31": leftin(char, 240, x_off, y_off),
            =="l32": leftin(char, 640, x_off, y_off),
            =="l33": leftin(char, 1040, x_off, y_off),
            =="l21": leftin(char, 400, x_off, y_off),
            =="l22": leftin(char, 880, x_off, y_off),
            =="l11": leftin(char, 640, x_off, y_off),

            =="thide": thide(char, x_off, y_off),
            =="lhide": lhide(char, x_off, y_off),
        }
    }
}

hide_character = (tokens, x_off: @number = 0, y_off: @number = 0) {
    char = tokens[0][0]
    if CHARACTERS[char].visible == false { return }

    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + 300,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: hide_char_funcs[char],
        PICKUP_MODE: 2, // toggle
        ACTIVATE_GROUP: true, // on
    })

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: CHARACTERS[char].pos.x, y: CHARACTERS[char].pos.y - 5}
}



python_single_line = (tokens) {
    // return if the line is not setting a variable (change later)
    if !("=" in tokens) { return }
    variable = tokens[0]
    value = tokens[2]

    // s_name = "Sayori"
    if variable.substr(1, 6) == "_name" { // if it sets someone's name
        CHARACTERS[variable[0]].name = value.replace('"', "").replace("'", "")
    }
}


let labels = {}
call_label = (label_name: @string) {
    let current_code_blocks = []
    let i_line = 0
    for line in labels[label_name] {
        [__tokens, tabs] = labels[label_name][i_line]
    
        command = __tokens[0]
        if !(command in TOKENS) && command[0] != '"' { i_line ++; continue } // if its not a valid token/word
        tokens = __tokens[1:] // remove the command bit from tokens

        if command == "return" { break }

        match command {
            in CHARACTERS_TOKENS: say_character(command, tokens, 300, 15, 169, 75),
            =="scene": set_scene(tokens, labels[label_name][i_line+1], 300, 13),
            =="show": show_character(tokens, 300, 13),
            =="hide": hide_character(tokens, 300, 13),
            =="$": python_single_line(tokens),
            =="with": with(tokens, 300, 13),
            =="call": call_label(tokens[0]),
        }
        
        // if narrator
        if command[0] == "\"" && tokens.length == 0 {
            say_narrator(command, 300, 13)
        }
    
        // doing it like this cuz u cant break in a match statement lmao
        // im gonna change this later so it just resumes instead of breaking
        if command == "call" { break }

        // $.print(modified_line)
        i_line ++
    }
}











create_scene_wiper_thing(1000, 60)
// make bg invisible
$.add(obj{
    OBJ_ID: 1007, // alpha trigger
    X: -45, Y: 369,
    TARGET: _BACKGROUNDS_GROUP,
    OPACITY: 0,
    DURATION: 0,
})


// placeholder colors, remove this later
character_colors = ["195a0.8a0.96a0a0", "125a0.59a0.78a0a0", "304a0.53a0.95a0a0", "281a0.80a0.96a0a0"]

// generate and add characers
for i in 0..MAIN_CHARACTERS_KEYS.length {
    // placeholder
    $.add(obj{
        OBJ_ID: 211, // white block
        X: 80*3, Y: 150,
        GROUPS: [CHARACTERS[MAIN_CHARACTERS_KEYS[i]].group, _SCENE_GROUP],
        COLOR: _RED_COLOR,
        HVS: character_colors[i],
        HVS_ENABLED: true,
        SCALING: 4,
        Z_ORDER: -2,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    // alpha = 0 at the start to hide the characters
    $.add(obj{
        OBJ_ID: 1007, // alpha trigger
        X: -45, Y: 420,
        TARGET: CHARACTERS[MAIN_CHARACTERS_KEYS[i]].group,
        OPACITY: 0,
        DURATION: 0,
    })
}

// generate and add all bgs
for bg in 0..BACKGROUNDS.length {
    // jpeg(bg+".png", 42, 0)
    _BG_GROUPS.push(@group(998 - _BG_GROUPS.length))
    image(BACKGROUND_FILE_NAMES[bg], _BG_GROUPS[-1], 42, 4)
}

// all labels, custom for loop
// let labels = {} // moved to just before call_label()
let line_idx_for_labels = 0
while line_idx_for_labels < lines.length - 1 {
    if !("label" in lines[line_idx_for_labels]) { line_idx_for_labels ++; continue }

    // we already know the line starts with "label" so we can just gen the tokens
    [__tokens, label_tabs] = generate_line_tokens(lines[line_idx_for_labels])

    if __tokens[0] != "label" { line_idx_for_labels ++; continue } // if the command isnt "label", aka if we found it in a character dialogue or smth
    label_name = __tokens[1].split(":")[0] // to remove the colon that the lexer didnt remove

    if label_name in LABELS_EXCLUSION_LIST { line_idx_for_labels ++; continue }

    req_tabs = label_tabs + 1

    let labels[label_name] = []

    // check if its in the current label & pregenerate the line tokens while doing so
    let i_line = line_idx_for_labels
    for line in lines[line_idx_for_labels + 1:] { // this might be wrong
        if line.length == 0 { line_idx_for_labels ++; i_line ++; continue } // skip empty lines

        [tokens, tabs] = generate_line_tokens(line)
        if tabs < req_tabs { line_idx_for_labels = i_line; break } // not in the current label
        // if tokens[0] == "return" { break } // moved to call_label()
        labels[label_name].push([tokens, tabs])
        i_line ++
    }
    
    if label_name == "ch0_main" { call_label(label_name) }
}

$.add(obj{ // follow player
    OBJ_ID: 901, // move trigger id
    X: 225, Y: -135,
    TARGET: _SCENE_GROUP,
    MOVE_X: PLAYER_SPEED*30*LEVEL_DURATION, // move to player
    DURATION: LEVEL_DURATION,
})

$.add(obj{ // so the level is long enough or something
    OBJ_ID: 1,
    X: PLAYER_SPEED*30*LEVEL_DURATION, Y: -69,
})

$.add(obj{ // add invisible trigger at the start
    OBJ_ID: 1007, // alpha trigger id
    X: -31, Y: -69,
    TARGET: _INVISIBLE_GROUP,
    OPACITY: 0,
    DURATION: 0,
})


change_dialog = !{ // change through dialog boxes
    if in_scene_transition_counter == 0 {
        _TEXT_GROUP.move(0, -100, 0)
    }
}

// gonna change soom
on(gs.button_a(), change_dialog)
on(gs.button_b(), change_dialog)

generate_dialogue_box()
generate_borders(302, 60)

if CACHE_IMAGES { $.writefile("./cache_output.txt", "{"+cached_bgs.map((k, v) => '"'+k+"\": \""+v+'"').join(", ")+"}") }
$.print("words: ", words)
